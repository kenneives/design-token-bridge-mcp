import type { DesignTokens } from "../types/tokens.js";

/**
 * Generate Kotlin/Jetpack Compose Material 3 theme files from universal tokens.
 */
export function generateMaterial3Theme(tokens: DesignTokens): string {
  const sections: string[] = [];

  sections.push("// Generated by design-token-bridge-mcp");
  sections.push("// Do not edit manually â€” regenerate from design tokens\n");
  sections.push('package com.example.ui.theme\n');
  sections.push("import androidx.compose.material3.*");
  sections.push("import androidx.compose.ui.graphics.Color");
  sections.push("import androidx.compose.ui.text.TextStyle");
  sections.push("import androidx.compose.ui.text.font.FontFamily");
  sections.push("import androidx.compose.ui.text.font.FontWeight");
  sections.push("import androidx.compose.ui.unit.sp");
  sections.push("import androidx.compose.foundation.shape.RoundedCornerShape");
  sections.push("import androidx.compose.ui.unit.dp\n");

  // Colors
  if (tokens.colors) {
    sections.push("// --- Colors ---\n");

    // Map semantic colors to Material 3 roles
    const colorMap = buildM3ColorMap(tokens.colors);

    sections.push("val LightColorScheme = lightColorScheme(");
    for (const [role, hex] of Object.entries(colorMap)) {
      sections.push(`    ${role} = Color(0xFF${hex.slice(1)}),`);
    }
    sections.push(")\n");

    // Also export raw colors
    sections.push("// Raw color values");
    for (const [name, token] of Object.entries(tokens.colors)) {
      const constName = toPascalCase(name);
      sections.push(`val ${constName} = Color(0xFF${token.value.slice(1)})`);
    }
    sections.push("");
  }

  // Typography
  if (tokens.typography) {
    sections.push("// --- Typography ---\n");
    sections.push("val AppTypography = Typography(");
    for (const [name, token] of Object.entries(tokens.typography)) {
      const m3Name = mapToM3TypographyRole(name);
      if (!m3Name) continue;

      const parts: string[] = [];
      if (token.fontFamily) {
        parts.push(`        fontFamily = FontFamily.Default`);
      }
      if (token.fontWeight) {
        parts.push(`        fontWeight = FontWeight(${token.fontWeight})`);
      }
      parts.push(`        fontSize = ${token.fontSize}.sp`);
      if (token.lineHeight) {
        parts.push(`        lineHeight = ${token.lineHeight}.sp`);
      }
      if (token.letterSpacing) {
        parts.push(`        letterSpacing = ${token.letterSpacing}.sp`);
      }

      sections.push(`    ${m3Name} = TextStyle(`);
      sections.push(parts.join(",\n") + ",");
      sections.push("    ),");
    }
    sections.push(")\n");
  }

  // Shapes
  if (tokens.radii) {
    sections.push("// --- Shapes ---\n");
    sections.push("val AppShapes = Shapes(");

    const radiiEntries = Object.entries(tokens.radii).sort((a, b) => a[1] - b[1]);
    const shapeRoles = ["extraSmall", "small", "medium", "large", "extraLarge"];

    for (let i = 0; i < Math.min(radiiEntries.length, shapeRoles.length); i++) {
      sections.push(
        `    ${shapeRoles[i]} = RoundedCornerShape(${radiiEntries[i][1]}.dp),`
      );
    }
    sections.push(")\n");
  }

  return sections.join("\n");
}

function buildM3ColorMap(
  colors: Record<string, { value: string; category?: string }>
): Record<string, string> {
  const map: Record<string, string> = {};

  for (const [name, token] of Object.entries(colors)) {
    const lower = name.toLowerCase();
    if (lower.includes("primary") && !lower.includes("on")) {
      map.primary = token.value;
    } else if (lower === "on-primary" || lower === "onprimary") {
      map.onPrimary = token.value;
    } else if (lower.includes("secondary") && !lower.includes("on")) {
      map.secondary = token.value;
    } else if (lower.includes("surface") && !lower.includes("on")) {
      map.surface = token.value;
    } else if (lower.includes("background") && !lower.includes("on")) {
      map.background = token.value;
    } else if (lower.includes("error") && !lower.includes("on")) {
      map.error = token.value;
    }
  }

  return map;
}

function mapToM3TypographyRole(name: string): string | null {
  const lower = name.toLowerCase().replace(/[-_]/g, "");
  const roles: Record<string, string> = {
    displaylarge: "displayLarge",
    displaymedium: "displayMedium",
    displaysmall: "displaySmall",
    headlinelarge: "headlineLarge",
    headlinemedium: "headlineMedium",
    headlinesmall: "headlineSmall",
    titlelarge: "titleLarge",
    titlemedium: "titleMedium",
    titlesmall: "titleSmall",
    bodylarge: "bodyLarge",
    bodymedium: "bodyMedium",
    bodysmall: "bodySmall",
    labellarge: "labelLarge",
    labelmedium: "labelMedium",
    labelsmall: "labelSmall",
  };
  return roles[lower] ?? null;
}

function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]/)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join("");
}
