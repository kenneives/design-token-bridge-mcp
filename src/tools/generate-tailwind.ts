import type { DesignTokens } from "../types/tokens.js";

/**
 * Generate a Tailwind config from universal tokens.
 */
export function generateTailwindConfig(
  tokens: DesignTokens,
  format: "esm" | "cjs" = "esm"
): string {
  const theme: Record<string, unknown> = {};

  if (tokens.colors) {
    const colors: Record<string, string> = {};
    for (const [name, token] of Object.entries(tokens.colors)) {
      colors[name] = token.value.toLowerCase();
    }
    theme.colors = colors;
  }

  if (tokens.typography) {
    const fontSize: Record<string, string | [string, Record<string, string>]> = {};
    for (const [name, token] of Object.entries(tokens.typography)) {
      const size = pxToRem(token.fontSize);
      const opts: Record<string, string> = {};
      if (token.lineHeight) opts.lineHeight = pxToRem(token.lineHeight);
      if (token.letterSpacing) opts.letterSpacing = pxToRem(token.letterSpacing);
      if (token.fontWeight) opts.fontWeight = String(token.fontWeight);

      if (Object.keys(opts).length > 0) {
        fontSize[name] = [size, opts];
      } else {
        fontSize[name] = size;
      }
    }
    theme.fontSize = fontSize;

    // Extract unique font families
    const families = new Map<string, string[]>();
    for (const [name, token] of Object.entries(tokens.typography)) {
      if (token.fontFamily && !families.has(token.fontFamily)) {
        families.set(token.fontFamily, [token.fontFamily, "sans-serif"]);
      }
    }
    if (families.size > 0) {
      const fontFamily: Record<string, string[]> = {};
      for (const [family, stack] of families) {
        fontFamily[family.toLowerCase().replace(/\s+/g, "-")] = stack;
      }
      theme.fontFamily = fontFamily;
    }
  }

  if (tokens.spacing) {
    const spacing: Record<string, string> = {};
    for (const [name, value] of Object.entries(tokens.spacing)) {
      spacing[name] = pxToRem(value);
    }
    theme.spacing = spacing;
  }

  if (tokens.radii) {
    const borderRadius: Record<string, string> = {};
    for (const [name, value] of Object.entries(tokens.radii)) {
      borderRadius[name] = `${value}px`;
    }
    theme.borderRadius = borderRadius;
  }

  if (tokens.elevation) {
    const boxShadow: Record<string, string> = {};
    for (const [name, token] of Object.entries(tokens.elevation)) {
      const { shadowOffset, shadowRadius, shadowColor, shadowOpacity } = token;
      boxShadow[name] =
        `${shadowOffset.x}px ${shadowOffset.y}px ${shadowRadius}px ${shadowColor}${Math.round(shadowOpacity * 255).toString(16).padStart(2, "0").toLowerCase()}`;
    }
    theme.boxShadow = boxShadow;
  }

  const config = {
    theme: {
      extend: theme,
    },
  };

  const json = JSON.stringify(config, null, 2);

  if (format === "cjs") {
    return `// Generated by design-token-bridge-mcp\n/** @type {import('tailwindcss').Config} */\nmodule.exports = ${json};\n`;
  }

  return `// Generated by design-token-bridge-mcp\n/** @type {import('tailwindcss').Config} */\nexport default ${json};\n`;
}

function pxToRem(px: number): string {
  return `${(px / 16).toFixed(4).replace(/0+$/, "").replace(/\.$/, "")}rem`;
}
